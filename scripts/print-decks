#!/usr/bin/env node

// @ts-check

/**
 * @file
 * Print all slide decks to PDF.
 */

// TODO: Rewrite all local URLs to point to the actual site URL.
// TODO: Print specific slides only.

const http = require("http")
const fs = require("fs/promises")
const handler = require("serve-handler")
const puppeteer = require("puppeteer")

const PORT = 8090
const URL = `http://localhost:${PORT}`
const PUBLIC_DIR = "_site"
const DECKS_DIR = `src/decks`

const server = http.createServer((request, response) => {
  return handler(request, response, { public: PUBLIC_DIR })
})

server.listen(PORT, () => {
  console.log(`print-decks server running at ${URL}.`)
})

//
;(async () => {
  // TODO: num should be a command line arg
  const num = 3
  const paddedNum = num.toString().padStart(2, "0")
  const files = await fs.readdir(DECKS_DIR)
  const deck = files
    .find((file) => file.endsWith(".md") && file.startsWith(paddedNum))
    // Remove extension
    ?.slice(0, -3)

  if (!deck) {
    // TODO
  }

  const browser = await puppeteer.launch()

  const pdfPath = await printDeck(browser, deck)
  console.log(`Printed ${pdfPath}.`)

  await browser.close()
  process.exit()
})()

/**
 *
 * @param {import("puppeteer").Browser} browser
 * @param {string} deck
 * @returns {Promise<string>}
 */
async function printDeck(browser, deck) {
  const page = await browser.newPage()

  debugPageRequests(page)

  await page.goto(`${URL}/decks/${deck}?print-pdf`, { waitUntil: "load" })
  // Just in case
  await page.waitForTimeout(2000)

  const path = `${DECKS_DIR}/${deck}.pdf`
  await page.pdf({
    path,
    printBackground: true,
    preferCSSPageSize: true,
  })

  await page.close()

  return path
}

/**
 * @param {import("puppeteer").Page} page
 */
function debugPageRequests(page) {
  const reqs = new Map()
  page
    .on("request", (e) => {
      reqs.set(e.url(), null)
    })
    .on("requestfailed", (e) => {
      reqs.set(e.url(), false)
    })
    .on("requestfinished", (e) => {
      reqs.set(e.url(), true)
    })
    .on("requestservedfromcache", (e) => {
      reqs.set(e.url(), true)
    })
    .on("load", () => {
      const failedReqs = new Map()
      for (const [key, value] of reqs) {
        if (value === null || value === false) {
          failedReqs.set(key, value)
        }
      }

      if (failedReqs.size) {
        console.log("Failed request from page", page.url())
        console.log({ failedReqs })
      }
    })
}
